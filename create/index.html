---
layout: default
---

<section class="row hero-row no-border">
    <div class="wrapper">
        <div class="six-col">
            <h1 class="hero-row__heading">Learn to make a snap</h1>
            <div class="five-col">
                <img class="for-small" src="{{ site.asset_path }}e5388dd6-snaps-hero%403x-1.png?w=480" alt="" />
            </div>
            <p class="intro">Snapcraft is a snappy packaging tool.</p>
        </div>
        <div class="six-col last-col">
            <img class="not-for-small" src="{{ site.asset_path }}e5388dd6-snaps-hero%403x-1.png?w=600" alt="" />
       </div>
    </div>
</section>

<section class="row">
    <div class="wrapper">
        <div class="eight-col">
            <h2 id="requirements">Requirements</h2>

            <p>To take this tour of snaps and Snapcraft, you'll need to have Snapcraft 2.11 or later installed. If you've already installed Snapcraft you can check the version:</p>

            <pre class="command-line"><code>$ snapcraft --version
2.11</code></pre>

            <p>If you haven't installed Snapcraft, it's available on Ubuntu 16.04 LTS:</p>

            <pre class="command-line"><code>$ sudo apt install snapcraft</code></pre>

            <p>It will also install and run on any Linux distribution with an up-to-date version of <a class="external" href="http://www.ubuntu.com/cloud/lxd">LXD, the container hypervisor</a>.</p>

            <h2 id="tour">Take the snapcraft tour</h2>

            <p>This tour walks you through the making of snaps. It starts with an overview of the snap format before introducing you to Snapcraft, the most widely used tool for creating snaps. After running through the basics of using Snapcraft the tour takes an in depth look at the key components that make up a snap. By the end of the tour you'll know how to create snaps so, if you want to, you can create them by hand or make your own snappy tools. </p>

            <p>The tour includes all the example source code and files in a series of subdirectories, which you load using the Snapcraft tool:</p>

            <pre class="command-line"><code>$ snapcraft tour
Snapcraft tour initialized in ./snapcraft-tour/
Instructions are in the README, or http://snapcraft.io/create/#tour</code></pre>

            <p>Each stage of the tour is in a separate subdirectory, with number prefixes showing the sequence. In each directory you'll find a README with the instructions from this page relevant to that directory, so you don't need to continually switch between the browser and your terminal as you follow the tour. </p>

            <p>Unless you specify a different directory name, the tour will be created in a new <code>snapcraft-tour</code> subdirectory in your current working directory. The directory structure will look like:</p>

            <pre class="command-line"><code>$ ls snapcraft-tour/**
snapcraft-tour/README.md

snapcraft-tour/00-SNAPCRAFT:
01-easy-start  02-parts

snapcraft-tour/10-SNAPS:
01-service  02-service-confined

snapcraft-tour/20-PARTS-PLUGINS:
01-reusable-part</code></pre>

            <p>You can cd into each directory and work through the README, or follow along on this page.</p>

            <h3 id="snapcraft-00">00 - SNAPCRAFT</h3>

            <h4 id="easy-start-01">01-easy-start: a single snapcraft.yaml describes a snap</h4>

            <p>Snapcraft uses a single text file to describe the entire build process for a snap: the snapcraft.yaml file. Over the course of this tour you'll learn how to create this file for your own snaps. You can see an example in this directory:</p>

            <pre class="command-line"><code>$ cd snapcraft-tour/00-SNAPCRAFT/01-easy-start
$ ls
snapcraft.yaml</code></pre>

            <p>Notice that <code>snapcraft.yaml</code> is the only file in the directory. Snapcraft doesn't need anything else as it will fetch everything it needs to build the snap, using the <code>snapcraft.yaml</code> description for the snap. Take a look inside:</p>

            <pre class="command-line"><code>$ more snapcraft.yaml
name: hello
version: "2.10"
summary: GNU Hello, the "hello world" snap
description: GNU hello prints a friendly greeting.
  This is part of the snapcraft tour at http://snapcraft.io/create/
confinement: strict

apps:
  hello:
    command: hello

parts:
  gnu-hello:
    plugin: autotools
    source: http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz</code></pre>

            <p>Don't worry about everything in there just yet. The snapcraft tool will interpret this file, fetch and install everything that is needed, build it, and give you a snap.</p>

            <p>Start by building this snap, noting that youâ€™ll be prompted for your system password each time you run <code>snapcraft</code>:</p>

            <pre class="command-line"><code>$ snapcraft
[sudo] password for [your user name]:  ***
Preparing to pull gnu-hello
Pulling gnu-hello
Preparing to build gnu-hello
Building gnu-hello
...
Snapped hello_2.10_amd64.snap</code></pre>

            <p>You'll have seen that Snapcraft fetched the source code, configured and built it. The snap is now available in your directory, along with new parts, prime, and snap directories.</p>

            <pre class="command-line"><code>$ ls
hello_2.10_amd64.snap  parts  snap  snapcraft.yaml  prime</code></pre>

            <p>As you can see a snap is a single file. The name of the file is based on information in the <code>snapcraft.yaml</code> (its name and version) and the architecture you're building on: <code>&lt;name&gt;_&lt;version&gt;_&lt;arch&gt;.snap</code>. </p>

            <p>Here, the snap was built on an amd64 machine, so the architecture used in the file name reflects that. The following commands use globs so you don't need to replace the architecture accordingly.</p>

            <p>Now, everything you need for the hello app is inside the snap file. You can install it locally:</p>

            <pre class="command-line"><code>$ sudo snap install hello_2.10_*.snap
hello 2.10 installed


64.64 MB / 64.64 MB [=============================] 100.00 % 3.97 MB/s

Name   Version  Rev     Developer  Notes
hello  2.10     X1</code></pre>

            <p>Congratulations, you've just made and installed your first snap.</p>

            <p>Note that the snap has both a version and a revision.</p>

            <p>The version is purely human-readable, it isn't used for any particular purpose other than keeping you aware of what's on your system. Two different snaps can claim to have the same version (in fact, when you have daily builds of a snap, it will almost always have a version like "2.1b3" for every build until the version is updated).</p>

            <p>The revision for a snap is unique. In this example, because you built the snap locally, it gets a local alphanumeric revision that is unique on this machine only. When you load a snap from the store, the revision is an integer number that exactly identifies the snap that is installed. While you can't do this for local revisions, with snaps loaded from the store you can compare revisions on two machines to determine if they have exactly the same content installed.</p>

            <p>You can also confirm details of all the snaps you've installed:</p>

            <pre class="command-line"><code>$ snap list
Name         Version               Rev  Developer  Notes
hello        2.10                  X1              -
ubuntu-core  16.04+20160531.11-56  122  canonical  -</code></pre>

            <p>Finally, run your snap:</p>

            <pre class="command-line"><code>$ hello
Hello, world!</code></pre>

            <p>Next, you might want to do some housekeeping and get rid of all the files that were created in the process of building the snap:</p>

            <pre class="command-line"><code>$ snapcraft clean
Cleaning snapping area for gnu-hello
Cleaning staging area for gnu-hello
Cleaning build for gnu-hello
Cleaning pulled source for gnu-hello
Cleaning up parts directory
Cleaning up priming area

$ ls
hello_2.10_amd64.snap  snapcraft.yaml</code></pre>

            <p>In some trees it may be preferable to name the snapcraft YAML file <code>.snapcraft.yaml</code>. Snapcraft will look for <code>snapcraft.yaml</code> or <code>.snapcraft.yaml</code>, and will use either one, but it will error out if you've both there. If you're uncertain, the recommendation is to use <code>snapcraft.yaml</code>.</p>

            <p>One last thing to be aware of is that the <code>snapcraft</code> command is shorthand for the real command, which is <code>snapcraft snap</code>. You can see this from the help for snapcraft:</p>

            <pre class="command-line"><code>$ snapcraft help
Usage:
  snapcraft [options] [--enable-geoip --no-parallel-build]
  snapcraft [options] init
  snapcraft [options] pull [&lt;part&gt; ...]  [--enable-geoip]
  snapcraft [options] build [&lt;part&gt; ...] [--no-parallel-build]
  snapcraft [options] stage [&lt;part&gt; ...]
  snapcraft [options] prime [&lt;part&gt; ...]
  snapcraft [options] clean [&lt;part&gt; ...] [--step &lt;step&gt;]
  snapcraft [options] snap [&lt;directory&gt; --output &lt;snap-file&gt;]
  snapcraft [options] cleanbuild
  snapcraft [options] login
  snapcraft [options] logout
  snapcraft [options] upload &lt;snap-file&gt;
  snapcraft [options] list-plugins
  snapcraft [options] tour [&lt;directory&gt;]
  snapcraft [options] help (topics | &lt;plugin&gt; | &lt;topic&gt;) [--devel]
  snapcraft (-h | --help)
  snapcraft --version</code></pre>

            <p>By the time you've finished this tour, you'll know your way around most of these.</p>

            <p>Here are the things you should be comfortable with, before you move on. A <code>snapcraft.yaml</code> describes the snap, and it should be at the top of your directory tree.</p>

            <p>The Snapcraft tool will do all the work if you just type <code>snapcraft</code> or <code>snapcraft snap</code>.</p>

            <p>The resulting snap is a single file called <code>name_version_arch.snap</code>.</p>

            <p>You can install snaps directly with <code>snap install &lt;snapfile.snap&gt;</code>.</p>

            <p>Locally created snaps have their own local revisions that are specific to that system.</p>

            <p>Snap revisions uniquely identify the exact build of a snap that is installed. snapcraft clean will remove all the build artifacts.</p>

            <p>The <code>snapcraft.yaml</code> file can optionally be called <code>.snapcraft.yaml</code>.</p>

            <h3 id="parts-02">02-parts: Snapcraft makes snaps out of parts</h3>

            <p>When you make a snap, you bundle together all the pieces you want your app to provide for itself, rather than consume them from the base operating system. Normally, that means combining several different pieces of code, because your app probably isn't so simple that it consists of a single piece of code that runs without any supporting components.</p>

            <p>In the <code>snapcraft.yaml</code> of the hello app you'll have noticed a section called parts:</p>

            <pre class="command-line"><code>  gnu-hello:
    plugin: autotools
    source: http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz</code></pre>

            <p>This is the simplest possible snap. It has only one part, called <code>gnu-hello</code>. This part is also just about the simplest kind of part. It only has two attributes; the source code location (which is instructing Snapcraft to pull the source from the gnu.org website) and the plugin to use when building this part, namely <code>autotools</code>.</p>

            <p>Many parts will specify an explicit file version for the source, as this one does. This ensures that everybody who builds this part gets exactly the same code, because it's fetched from the same file. However, you could point to a source that will change every time there is a new release:</p>

            <pre class="command-line"><code>parts:
  foo-stable:
    plugin: autotools
    source: http://releases.foo.org/download/foo-stable.tar.gz</code></pre>

            <p>Now, every time someone runs Snapcraft with the foo-stable part, they might get a different codebase from the previous person to build the same part, because the <code>foo-stable.tar.gz</code> file might have changed. It's generally preferable to be explicit with your parts, so people know what they are getting and can reproduce the snap build process easily.</p>

            <p>You can refer to local source as well. For example, you can make a part that refers to a subdirectory where the part source code is kept:</p>

            <pre class="command-line"><code>parts:
  foo-forked:
    plugin: autotools
    source: ./src/foo</code></pre>

            <p>You can ask Snapcraft itself for a full specification of all the ways to refer to source:</p>

            <pre class="command-line"><code>$ snapcraft help sources
Common 'source' options.

Unless the part plugin overrides this behaviour, a part can use these
'source' keys in its definition. They tell snapcraft where to pull source
code for that part, and how to unpack it if necessary.

 - source: url-or-path

    A URL or path to some source tree to build. It can be local
    ('./src/foo') or remote ('https://foo.org/...'), and can refer to a
    directory tree or a tarball or a revision control repository
    ('git:...').

  - source-type: git, bzr, hg, tar or zip

    In some cases the source string is not enough to identify the version
    control system or compression algorithm. The source-type key can tell
    snapcraft exactly how to treat that content.

  - source-branch: &lt;branch-name&gt;

    Snapcraft will checkout a specific branch from the source tree. This
    only works on multi-branch repositories from git and hg (mercurial).

  - source-tag: &lt;tag&gt;

    Snapcraft will checkout the specific tag from the source tree revision
    control system.

  - source-subdir: path

    Snapcraft will checkout the repository or unpack the archive referred to
    by the 'source' keyword into parts/&lt;part-name&gt;/src/ but it will only
    copy the specified subdirectory into parts/&lt;part-name&gt;/build/

Note that plugins might well define their own semantics for the 'source'
keywords, because they handle specific build systems, and many languages
have their own built-in packaging systems (think CPAN, PyPI, NPM). In those
cases you want to refer to the help text for the specific plugin.

  snapcraft help &lt;plugin&gt;</code></pre>

            <p>The more interesting attribute of <code>gnu-hello</code> is the plugin, <code>autotools</code>. Snapcraft has a plugin system so that it can drive different build systems for different parts. In this case, <code>gnu-hello</code> uses the <code>autotools</code> build conventions â€” essentially <code>./configure</code>, <code>make</code>, and <code>make install</code>. You can generally snap anything that follows that convention very easily, just use the <code>autotools</code> plugin for the part.</p>

            <p>Snapcraft can tell you which plugins it has installed:</p>

            <pre class="command-line"><code>$ snapcraft list-plugins
ant        copy    kernel  nodejs   tar-content
autotools  go      make    python2
catkin     jdk     maven   python3
cmake      kbuild  nil     scons</code></pre>

            <p>Each of these plugins knows how to drive a particular set of conventions for a particular build system. The important distinction is that Snapcraft is not itself a build system. It doesn't replace <code>make</code>, <code>autoconf</code>, or <code>scons</code>. Instead, a part describes which of those build systems to use, so that Snapcraft can drive the build system that the part author selected.</p>

            <p>The next example is a more interesting snap that uses two parts:</p>

            <pre class="command-line"><code>$ cd ../02-parts
$ more snapcraft.yaml
name: hello-debug
version: "2.10"
summary: GNU Hello with Bash for debugging
description: GNU hello prints a friendly greeting.
  This is part of the snapcraft tour at http://snapcraft.io/create/

apps:
  hello:
    command: hello
  bash:
    command: bash

parts:
  gnu-hello:
    plugin: autotools
    source: http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz
  gnu-bash:
    plugin: autotools
    configflags: ["--infodir=/var/bash/info"]
    source: http://ftp.gnu.org/gnu/bash/bash-4.3.tar.gz</code></pre>

            <p>Now build and install it:</p>

            <pre class="command-line"><code>$ snapcraft
...
$ sudo snap install hello-debug_2.10_*.snap
...</code></pre>

            <p>The result is that two apps are exposed:</p>

            <ul>
                <li>The hello app pointing to the hello binary (the command) inside the snap. The command can be executed using <code>hello-debug.hello</code></li>
                <li><p>The bash app pointing to the bash binary (command) and is executed using <code>hello-debug.bash</code></p>
                <p>$ hello-debug.hello $ hello-debug.bash</p></li>
            </ul>

            <p>You'll also see that Snapcraft has created various subdirectories:</p>

            <ul>
                <li>parts/</li>
                <li>stage/</li>
                <li>prime/</li>
            </ul>

            <p><code>parts/</code> contains one subdirectory for each part: <code>gnu-bash</code> and <code>gnu-hello</code>. Each part's subdirectory has a <code>src/</code> directory (to where the code is pulled), <code>build/</code> where the build happens, and <code>install/</code> where <code>make install</code> is processed.</p>

            <p><code>stage/</code> is where all the content from <code>parts/&lt;part_name&gt;/install</code> is copied and consolidated in a single directory.</p>

            <p><code>prime/</code> is the actual snap content. The <code>stage/</code> directory is copied there. Binaries are stripped, wrappers are generated by Snapcraft, and the snap metadata files are also generated there. The final <code>.snap</code> file is just a <code>squashfs</code> archive of this <code>prime/</code> directory. You can use and debug the snap's content from here.</p>

            <h3 id="snapcraft-commands">Snapcraft commands</h3>

            <p>Snapcraft also lets you work with individual commands so you can update and customize your snap. This section looks at some of those options and shows how you could clean and rebuild the gnu-bash part. </p>

            <h4 id="clean">clean: Resetting individual parts or the whole snap</h4>

            <p><code>snapcraft clean</code> removes the directories and data created by Snapcraft. By default it will delete all the directories and data created by Snapcraft from your snap's directory. However, you can use <code>snapcraft clean &lt;part&gt;</code> to delete a specific part:</p>

            <pre class="command-line"><code>$ snapcraft clean gnu-bash
Cleaning priming area for gnu-bash
Cleaning staging area for gnu-bash
Cleaning build for gnu-bash
Cleaning pulled source for gnu-bash</code></pre>

            <p>As you can see <code>snapcraft clean</code> has now deleted all your directories from the <code>gnu-bash</code> part.</p>

            <pre class="command-line"><code>$ ls parts
gnu-hello</code></pre>

            <h4 id="pull">pull: Pulling dependencies to refresh code</h4>

            <p>When the source code in an online or local repository changes you can use <code>snapcraft pull</code> to pull the updated source code from that repository, remembering to do a <code>snapcraft clean</code> first. You can pull the code for all your dependencies or only the parts you know have changed by using <code>snapcraft pull &lt;part&gt;</code>.</p>

            <pre class="command-line"><code>$ snapcraft pull
Skipping pull gnu-hello (already ran)
Preparing to pull gnu-bash
Pulling gnu-bash </code></pre>

            <p>The <code>gnu-hello</code> had already been pulled, when you first built the snap, so it's not pulled again.</p>

            <p>As you can see <code>snapcraft pull</code> has created some new directories and populated <code>src/</code>:</p>

            <pre class="command-line"><code>$ ls parts/gnu-bash/**
parts/gnu-bash/bin:
pkg-config

parts/gnu-bash/build:

parts/gnu-bash/install:

parts/gnu-bash/src:
[...] lot of files
parts/gnu-bash/state:
pull

parts/gnu-bash/ubuntu:</code></pre>

            <h4 id="build">build: Build a specific part, or all of them</h4>

            <p>You can use <code>snapcraft build</code> to build any parts that haven't been built and install them in their part directory, or specify specific parts to be built:</p>

            <pre class="command-line"><code>$ snapcraft build
Skipping pull gnu-bash (already ran)
Skipping pull gnu-hello (already ran)
Preparing to build gnu-bash
Building gnu-bash
./configure --prefix= --infodir=/var/bash/info
[...]
Skipping build gnu-hello (already ran)</code></pre>

            <p>As you can see <code>snapcraft build</code> has now populated both the <code>build/</code> and <code>install/</code> directories:</p>

            <pre class="command-line"><code>$ ls parts/gnu-bash/build/
[...] lots of files

$ ls parts/gnu-bash/install/
[...] lots of files</code></pre>

            <h4 id="stage">stage: Move the files installed from different parts into a single directory</h4>

            <p>Having built all the parts for your snap, use <code>snapcraft stage</code> to move all the relevant content into stage/ (to prepare for creating the snap package):</p>

            <pre class="command-line"><code>$ snapcraft stage
Skipping pull gnu-bash (already ran)
Skipping pull gnu-hello (already ran)
Skipping build gnu-bash (already ran)
Skipping build gnu-hello (already ran)
Staging gnu-bash
Skipping stage gnu-hello (already ran)
As you can see snapcraft stage has now added stage/bin/bash:
$ ls stage/**
stage/bin:
bash  bashbug  hello

stage/share:
doc  info  locale  man

stage/var:
bash</code></pre>

            <h4 id="prime">prime: Move the files needed for the snap into place</h4>

            <p>Once you're satisfied with the snap created in the <code>stage/</code> directory, create the final snap in its correct location using <code>snapcraft prime</code>:</p>

            <pre class="command-line"><code>$ snapcraft prime
Skipping pull gnu-hello (already ran)
Skipping pull gnu-bash (already ran)
Skipping build gnu-hello (already ran)
Skipping build gnu-bash (already ran)
Skipping stage gnu-hello (already ran)
Skipping stage gnu-bash (already ran)
Skipping prime gnu-hello (already ran)
Priming gnu-bash </code></pre>

            <p>As you can see <code>snapcraft prime</code> has copied the content of <code>stage/</code> to <code>prime/</code> and added some wrapper and metadata scripts:</p>

            <pre class="command-line"><code>$ ls prime/
bin  command-bash.wrapper  command-hello.wrapper  meta  share  var
</code></pre>

            <p>However, in most cases once you've cleaned a part from your snap directories you can rebuild the part and snap using <code>snapcraft</code>, which by default will only rebuild any parts missing from your snap.</p>

            <h4 id="snap">snap: compress any directory into a single .snap squashfs file</h4>

            <p>The <code>snapcraft snap</code> command is essential, especially if you craft your own <code>prime/</code> directory. The directory name itself doesn't matter, you just need to ensure you provide any required wrapper and meta (<code>snap.yaml</code>) files, from your build system. Then <code>snapcraft snap</code> will create a snap from the folder content.</p>

            <p>The default action in the Snapcraft lifecycle is to compress the <code>prime/</code> directory into a single <code>.snap</code> squashfs file.</p>

            <pre class="command-line"><code>$ snapcraft snap prime/
Snapping 'hello-debug' -
Snapped hello-debug_2.10_amd64.snap</code></pre>

            <h4 id="snapcraft-commands-recap">Recap</h4>

            <p>In this section of the tour you've seen how a snap:</p>

            <ul>
                <li>Can deliver an application</li>
                <li>Is defined by a single <code>snapcraft.yaml</code> file</li>
                <li>Can (and in most cases will) be made up of several parts</li>
                <li>Is created in a number of stages that pull and build parts, before creating the snap package</li>
            </ul>

            <h3 id="snaps-10">10 - SNAPS</h3>

            <p>Now you'll build on the knowledge you've gained about snaps, by looking at the other types of snap app types and some of the key technology that underpins snaps.</p>

            <h4 id="apps">apps: defining services and commands</h4>

            <p>The example snap in the first part of this guide delivered a simple terminal application. However, you can deliver any type of application or service with a snap that you might do with a standard deb package. This example shows how you do this for a service:</p>

            <pre class="command-line"><code>$ cd ../../10-SNAPS/01-service
$ snapcraft
$ sudo snap install hello-world-service_0.1_*.snap --devmode
Name                 Version  Rev  Developer  Notes
hello-world-service  0.1      x1              devmode</code></pre>

            <p><code>--devmode</code> will be explained in the next chapter, so for now open http://localhost:8000 in your browser and you'll find the running web service.</p>

            <p>The key components of <code>snapcraft.yaml</code> that enabled this are:</p>

            <pre class="command-line"><code>parts:
  hello:
    plugin: nodejs
    source: .</code></pre>

            <p>Here the hello part uses the nodejs plugin, a plugin to handle Node.js projects. It takes all the npm information from <code>package.json</code>, including dependencies (if any) and installs them alongside the service's JavaScript code.</p>

            <pre class="command-line"><code>apps:
  hello-service:
    command: hello-world
    daemon: simple</code></pre>

            <p>Here the <code>hello-service</code> app is declared and specified as a simple (i.e. non-forking) daemon (a service that starts at boot and keeps running on your system). This daemon executes the <code>hello-world</code> command.</p>

            <h4 id="confinement-and-devmode">confinement and devmode</h4>

            <p>You may have noticed the <code>--devmode</code> option was used in snap install. Reinstall the snap without it:</p>

            <pre class="command-line"><code>$ sudo snap install hello-world-service_0.1_*.snap
Name                 Version  Rev  Developer  Notes
hello-world-service  0.1      x2              -</code></pre>

            <p>If you now open <a class="external" href="http://localhost:8000">http://localhost:8000</a> you get a 404 page with no content and it would seem that the service can't serve web requests now.</p>

            <p>All snaps run confined by default. They're able to access any functions in the snap and data written to their own private writable area, but have restricted and secured access to the system.</p>

            <p>The hello world service needs to listen to the network (a restricted and secured part of the system), but hasn't been setup with the additional permissions to do so yet.</p>

            <p>To simplify development, <code>--devmode</code> enables you to run the snap outside the confinement sandbox and get unrestricted access to system resources, in this case, listening to the network. However, you do need to tell the snap that it can run in devmode, by making a declaration in <code>snapcraft.yaml</code>:</p>

            <pre class="command-line"><code>$ more snapcraft.yaml
[...]
confinement: devmode</code></pre>

            <p>This enables quick iteration to perfect the functionality of the snap before you need to worry about making it work under confinement. It should be noted that snaps uploaded to the store with confinement set to devmode are not visible with the snap find command. However, devmode snaps can still be installed if you specify the exact snap name.</p>

            <h4 id="plugs-and-slots">plugs-and-slots: integration with the system and other snaps</h4>

            <p>However, once you're happy with the functionality of your snap you'll need to focus on its confinement.</p>

            <p>To enable snaps to access external resources (or make their own resources available to other snaps) a system of plugs and slots is used. A plug is a request for access to an external interface, while a slot is an interface provided by the snap.</p>

            <p>The <code>hello-world-service</code> snap needs to have access to the network, so it can listen for and serve requests, this access is requested using the [<code>network-bind</code>] plug. This plug is then declared in the <code>snapcraft.yaml</code>:</p>

            <pre class="command-line"><code>plugs: [network-bind]</code></pre>

            <p>Specifying the <code>network-bind</code> plug essentially pokes a hole in the otherwise-complete confinement, telling snappy that this snap requires access to the network through the <code>network-bind</code> interface. The plug then connects to the network-bind slot provided by the base OS as an helper.</p>

            <p>So now, without using <code>--devmode</code>,  you can run the confined version of the hello world service:</p>

            <pre class="command-line"><code>$ cd ../02-service-confined
$ snapcraft
$ sudo snap install hello-world-service_0.1_*.snap
Name                 Version  Rev  Developer  Notes
hello-world-service  0.1      x3              -</code></pre>

            <p>Open your browser at <a class="external" href="http://localhost:8000">http://localhost:8000</a>, the application looks identical to the previous example.</p>

            <p>Finally, there has been one further very important change made to the <code>snapcraft.yaml</code>:</p>

            <pre class="command-line"><code>confinement: strict</code></pre>

            <p>To indicate that this snap is now confined.</p>

            <h4 id="structure">structure: the directory layout of a snap</h4>

            <p>Now you've got to grips with some basic and advanced snap features, it's worth gaining an understanding of what's inside a snap. And seeing the snap's content is easy, as it's all in the <code>prime/</code> directory:</p>

            <pre class="command-line"><code>$ ls prime/**
prime/CHANGELOG.md  prime/command-hello-service.wrapper  prime/LICENSE  prime/README.md

prime/bin:
hello-world  node  npm

prime/etc:

prime/include:
node

prime/lib:
node_modules

<b>prime/meta:
snap.yaml</b>

prime/share:
doc  man  systemtap</code></pre>

            <p>Most of the content should be self explanatory, the obvious components to deliver the Node.js capabilities and the service. However the two highlighted files may not be so obvious.</p>

            <h4 id="wrapper">wrapper: defining how the binaries are launched</h4>

            <p>This file (<code>prime/command-hello-service.wrapper</code>) provides a small wrapper that will launch the real binaries: typically a small shell script that sets <code>PATH</code>, <code>LD_LIBRARY_PATH</code> or other runtime specific environment variables. Snapcraft generated these wrappers for you.</p>

            <h4 id="metadata">metadata: snap.yaml defines the properties of a snap</h4>

            <p>The <code>snap.yaml</code> file provides the configuration file for the snap's content and is similar to the <code>snapcraft.yaml</code> file, with two exceptions:</p>

            <pre class="command-line"><code>$ more snap/meta/snap.yaml
apps:
  hello-service:
    command: command-hello-service.wrapper
    daemon: simple
    plugs:
    - network-bind
  <b>architectures:
  - amd64</b>
confinement: strict
description: This example demonstrates how to have nodejs webserver. This is part
  of the snapcraft tour at http://snapcraft.io/create/
name: hello-world-service
summary: A hello world style nodejs webserver app
version: 0.1</code></pre>

            <p>The first exception is that <code>snap.yaml</code> includes a specification of the architecture that the snap has been built for <strong>(highlighted)</strong>. The second difference is that there is no parts definition (as the parts are now in the snap and no longer need to be defined).</p>

            <p>Armed with this information you can, if you wish, build your snap package more directly by:</p>

            <ul>
                <li>Creating a <code>prime/</code> directory</li>
                <li>Adding the built assets and code</li>
                <li>Adding a wrapper file</li>
                <li>Adding <code>meta/snap.yaml</code></li>
                <li>Running <code>snapcraft snap prime/</code></li>
            </ul>

            <p>And you'll have a hand crafted snap file.</p>

            <h4 id="snaps-recap-10">Recap</h4>

            <p>You've now added some depth to your knowledge of snaps and learned about:</p>

            <ul>
                <li>Delivering services (in addition to apps) in your snaps</li>
                <li>How all snaps are confined (unable to access system resources) but can be unconfined with <code>--devmode</code> to simplify development</li>
                <li>How plugs and slots enable snaps to consume resources outside the confinement (or make their own resources available to other snaps)</li>
                <li>The structure of a snap's content and the option to hand build a snap</li>
            </ul>

            <h3 id="parts-20">20 - PARTS &amp; PLUGINS</h3>

            <p>You first met parts at the start of this guide and have been working with them in all the examples so far. So, it's time to take a closer look at how parts work and the options they provide you. Then there are a couple of references for plugins, in case you would like to explore further.</p>

            <h4 id="parts-intro: A "part" is a reusable component of a snap">parts-intro: A "part" is a reusable component of a snap</h4>

            <p>Parts are reusable components that can be used when building a snap. They're analogous to a library that you would call in your program. There are three types of parts:</p>

            <p>Parts from local source that use local files on your machine. For example (as seen in <code>10-SNAPS/01-service/</code>):</p>

            <pre class="command-line"><code>parts:
  hello:
    plugin: nodejs
    source: .</code></pre>

            <p>Parts from online sources, such as <code>github</code>, <code>bzr</code>, <code>tarball</code>, or any code repository you like. For example:</p>

            <pre class="command-line"><code>parts:
  godd:
   plugin: go
    source: https://github.com/mvo5/godd.git
  gnu-hello:
   plugin: autotools
    source: http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz</code></pre>

            <p>You've already seen the last part in <code>00-SNAPCRAFT/01-easy-start/</code>.</p>

            <p>To see parts built and shared by others &mdash; <a class="external" href="https://wiki.ubuntu.com/Snappy/Parts">https://wiki.ubuntu.com/Snappy/Parts</a> </p>

            <p>The features of parts shared by this last method are the focus of our next example:</p>

            <pre class="command-line"><code>$ cd ../../20-PARTS-PLUGINS/01-reusable-part
$ snapcraft
$ sudo snap install hello-world-desktop_0.1_*.snap</code></pre>

            <p>Which can be run with the <code>hello-world-desktop</code> command as defined in the <code>snapcraft.yaml</code>:
apps:</p>

            <pre class="command-line"><code>hello-world-desktop:
  command: qt5-launch hello-world-desktop</code></pre>

            <p>But notice this involves an extra tool <code>qt5-launch</code>, which prepares the environment for launching the real application. These <code>qt5-launch</code> and <code>hello-world-desktop</code> commands come from:</p>

            <pre class="command-line"><code>parts:
  hello-world:
    plugin: cmake
    source: src/
    build-packages:
      - qtbase5-dev
    stage-packages:
      # Here for the plugins-- they're not linked in automatically.
      - libqt5gui5
    after: [qt5conf] # A part in the cloud</code></pre>

            <p>In this part definition:</p>

            <ul>
                <li><code>build-packages</code> lists the dependencies needed to build the contents of the snap. These aren't packed into the final snap. <code>qtbase5-dev</code> has been specified here since that package contains the headers, libraries, and tools needed to build the app</li>
                <li><code>stage-packages</code> lists the dependencies needed to actually run the contents of the snap. They'll be packed into the final snap. Here, the requirement is for the hello-world part to download and unpack <code>libqt5gui5</code> with all its dependencies. This method can reuse any of the 48000 .deb packages that traditional Ubuntu provides. It's really that easy: just specify the packages you need embedded into your snap</li>
                <li><code>after:</code> [<code>qt5conf</code>] lists the parts that must be staged before this part can be built. However, you may have noticed that this YAML doesn't actually contain the <code>qt5conf</code> part. That's because it's a part in the cloud, which is a way for collaborating, reusing, and sharing already-written parts. The previously mentioned <code>qt5-launch</code> tool comes from the <code>qt5conf</code> part, without any additional effort from you. This way you can make use of and build upon what others have created</li>
            </ul>

            <h4 id="sharing">sharing: Sharing your parts with other developers</h4>

            <p>If you would like to publish your own parts, you can contribute them on the wiki at <a class="external" href="https://wiki.ubuntu.com/snapcraft/parts">https://wiki.ubuntu.com/snapcraft/parts</a>.</p>

            <p>Your contributions will always be welcome!</p>

            <h4 id="plugins">plugins: Each part is built using a snapcraft plugin</h4>

            <p>Plugins tell Snapcraft how to build the content of the snap's parts. You'll probably use the supplied plugins for most of your snaps. However, you can add your own plugins for other languages. Details of how to do this are beyond this get started, but if you would like to explore more here are a couple of plugin examples and basic building details: </p>

            <h4 id="autoconf-make">autoconf-make: The standard "configure, make, make install" plugin</h4>

            <p><a class="external" href="https://github.com/ubuntu-core/snapcraft/blob/master/demos/libpipeline/snapcraft.yaml">See an example on Github</a></p>

            <p>Get more info from:</p>

            <pre class="command-line"><code>$ snapcraft help autotools
$ snapcraft help make</code></pre>

            <h4 id="golang">golang: The Golang plugin</h4>

            <p><a class="external" href="https://github.com/ubuntu-core/snapcraft/blob/master/demos/godd/snapcraft.yaml">See an example on Github</a></p>

            <p>Get more info from:</p>

            <pre class="command-line"><code>$ snapcraft help go
x-plugins: Local plugins</code></pre>

            <p>You can build your own plugin and reference it from your part. To do this, copy your plugin into <code>parts/plugins/x-&lt;plugin_name&gt;.py</code>.  Get inspiration from <a class="external" href="https://github.com/ubuntu-core/snapcraft/blob/master/snapcraft/plugins/go.py">https://github.com/ubuntu-core/snapcraft/blob/master/snapcraft/plugins/go.py</a></p>

            <h3 id="store-30">30 - STORE</h3>

            <p>In order to share your snaps with the world, you will need to publish them in the Store. First, create an account on <a class="external" href="https://myapps.developer.ubuntu.com/">https://myapps.developer.ubuntu.com/</a>. This is your developer portal. Here you can customize how your snap is presented, review each new upload, and control publishing.</p>

            <p>You'll need to choose a unique developer namespace as part of the account creation process. In a future version, developer branches of reserved name snaps will be referred to by this name (for example firefox@mark).</p>

            <p>Once you've confirmed your account, you're ready to start pushing your snaps to the Store. Make sure Snapcraft and snap know about you by logging in using the email address you provided at signup:</p>

            <pre class="command-line"><code>$ snapcraft login
$ snap login you@yourdomain.com</code></pre>

            <h4 id="devspace">devspace: You can generally publish your own version of a snap</h4>

            <p>You can publish your own version of a snap, provided you do so under a name you have rights to. New names can be registered by clicking the New Snap button on the developer portal, or by visiting: <a class="external" href="https://myapps.developer.ubuntu.com/dev/click-apps/register-name/">https://myapps.developer.ubuntu.com/dev/click-apps/register-name/</a></p>

            <p>Use "hello-" suffixed by your name for this exercise (for example hello-mark), since you don't have rights to the "hello" snap name.</p>

            <h4 id="names">names: you can reserve names for software you publish</h4>

            <p>You can follow the same registration process for names that you have rights.</p>

            <p>We can, if needed, rename snaps to ensure they match the expectations of most users. If you are the publisher most users expect for a name then claim it at: <a class="external" href="https://myapps.developer.ubuntu.com/dev/click-apps/register-name-dispute/">https://myapps.developer.ubuntu.com/dev/click-apps/register-name-dispute/</a></p>

            <h4 id="revisions">revisions: You get a new revision every time you push</h4>

            <p>Once you've registered your snap name, go back to your <code>snapcraft.yaml</code> file and update the name field. Run Snapcraft again to quickly rebuild with the new name. With that done, the new revision of your snap can be uploaded to the Store:</p>

            <pre class="command-line"><code>$ snapcraft upload hello-world_1.0_*.snap</code></pre>

            <h4 id="publication">publication: Users only see your published revisions</h4>

            <p>Uploading your snap won't make it immediately available for installation. You'll have to choose the channel(s) you wish to release into.</p>

            <p>There are four channels available for your use:</p>

            <ul>
                <li>Stable is what most users will consume and as the name suggests, should be your most polished and tested versions</li>
                <li>Candidate is used to vet uploads that should require no further code changes before moving to stable</li>
                <li>Beta is used to provide preview releases of semi-stable changes</li>
                <li>Edge is for your most recent changes, probably untested and with no guarantees attached</li>
            </ul>

            <p>Open the URL that was returned from <code>snapcraft upload</code> or open the snap from the developer portal front page: <a class="external" href="https://myapps.developer.ubuntu.com">https://myapps.developer.ubuntu.com</a></p>

            <p>You should see the 1.0 version in the lefthand column. Clicking on that link will bring up further details about this revision. Here you can edit the list of channels it should be released into.</p>

            <p>Click on the <code>Edit</code> link next to the Channels field. In the page that appears, select <code>Stable</code> and click <code>Save Changes</code>.</p>

            <p>Your upload is now ready to be released into the stable channel. Click the <code>Publish</code> button on the page you return to.</p>

            <p>The build you uploaded is now the selected revision in the stable channel, meaning that installs of your snap will select this upload by default.</p>

            <p>You can confirm this by installing the snap locally, replacing '<code>hello-mark</code>' with your snap name:</p>

            <pre class="command-line"><code>$ snap install hello-mark
Name        Version  Rev     Developer
hello-mark  1.0      1       sabdfl</code></pre>

            <h3 id="confinement-40">40 - CONFINEMENT</h3>

            <h4 id="confinement">confinement: specify how the snap can be used with the security sandbox</h4>

            <p>By default snaps run in a restrictive sandbox to ensure that snaps only access the system and other snaps in controlled ways. confinement is used in <code>snapcraft.yaml</code> to specify whether or not the snap is expected to work correctly when the specified interfaces are connected and the snap is confined. You specify strict to indicate the snap works properly when confined or devmode to indicate it only works properly when unconfined. If confinement is unspecified, the snap is assumed to work correctly when confined since developers are expected to develop their snaps for running in the sandbox. You're only allowed to upload snaps to the stable channel when strict confinement is used.</p>

            <p>When first making a snap it is often useful to specify confinement: devmode in your YAML like so:</p>

            <pre class="command-line"><code>name: hello-world-service
confinement: devmode
apps:
  hello-service:
    command: command-hello-service.wrapper
    daemon: simple
    plugs:
    - network-bind
...</code></pre>

            <p>You then would specify <code>--devmode</code> when installing the snap for testing and development (you must always specify <code>--devmode</code> when installing in devmode regardless of how confinement is set in your yaml). Once the application is working well in devmode, install it without specifying <code>--devmode</code> and iterate until it is working properly under confinement. When satisfied, you may indicate it works under confinement with:</p>

            <pre class="command-line"><code>name: hello-world-service
confinement: strict
apps:
  hello-service:
    command: command-hello-service.wrapper
    daemon: simple
    plugs:
    - network-bind
...</code></pre>

            <p>When debugging your snap when it is installed in strict mode (without <code>--devmode</code>), you can look in <code>/var/log/syslog</code> for sandbox denials. Alternatively, you may use the '<code>snappy-debug</code>' snap to assist you:</p>

            <pre class="command-line"><code>$ sudo snap install snappy-debug
$ sudo snap connect snappy-debug:log-observe ubuntu-core:log-observe
$ sudo /snap/bin/snappy-debug.security scanlog hello-world-service</code></pre>

            <p>This scanlog command will tail the syslog and make suggestions on what interfaces to use and suggest changes to make to your snap so it will work within the sandbox.</p>

        </div>
    </section>

    {% include contextual-footer.html %}
